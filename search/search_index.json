{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Moving Target Defence Simulator","text":"<p>Welcome to the documentation webpage for the Moving Target Defence Simulator. This webpage contains information on how to use the simulator, as well as information regarding how to download the simulator and some of its core features.</p> <p>Please navigate to the User Guide tab to learn how to use the simulator.</p> <p>Contact person: Jin Hong</p> <p>Email: jin.hong@uwa.edu.au</p>"},{"location":"codereview/","title":"Code Review","text":"<p>This page is used for understand the codebase and making it easier for others to understand </p>"},{"location":"codereview/#code-blocks-example","title":"Code blocks example","text":"test.py<pre><code>def foo():\n    if not bar:\n        return True\n</code></pre>"},{"location":"backend/endpoints/","title":"API Endpoints","text":""},{"location":"backend/endpoints/#post-simulate","title":"<code>[POST] /simulate</code>","text":""},{"location":"backend/endpoints/#description","title":"Description","text":"<p>This endpoint runs the <code>simulate_without_saving</code> function that can be found in <code>experiments/run.py</code>. It returns the resulting evaluation details of the simulation. Some elements such as the MTD Record and Attack Record require restructuring / further processing on the frontend to extract relevant data and be compatible with the Javascript graphing library d3.</p>"},{"location":"backend/endpoints/#request-body","title":"Request body","text":"<pre><code>{\n  \"finishTime\":int (optional),\n  \"mtdInterval\":int,\n  \"scheme\":string,\n  \"totalNodes\":int,\n  \"seed\": int (optional)\n}\n</code></pre>"},{"location":"backend/endpoints/#sample-request","title":"Sample request","text":"<pre><code>{\n  \"finishTime\": 3000,\n  \"mtdInterval\": 200,\n  \"scheme\": \"random\",\n  \"totalNodes\": 100\n}\n</code></pre>"},{"location":"backend/endpoints/#sample-response","title":"Sample response","text":"<ul> <li>Main <pre><code>{\n  \"network\": {},\n  \"mtd_record\": {},\n  \"attack_record\": {},\n  \"compromise_checkpoint_metrics\": [],\n}\n</code></pre></li> <li>network <pre><code>{\n  \"network\": {\n    \"directed\": false,\n    \"links\": [\n      { \"source\": 0, \"target\": 13 },\n      { \"source\": 2, \"target\": 10 },\n      ...\n    ],\n    \"nodes\": [\n      {\n        \"host\": {\n          \"compromised\": true,\n          \"compromisedServices\": [1, 3, 4, 6, 7, 9],\n          \"hostId\": 0,\n          \"hostUuid\": \"4806a31a-3f71-4a8d-99d8-880f83547621\",\n          \"ip\": \"161.99.9.59\",\n          \"osType\": \"freebsd\",\n          \"osVersion\": \"12\",\n          \"pUCompromise\": false,\n          \"totalNodes\": 10,\n          \"totalServices\": 9,\n          \"totalUsers\": 5\n        },\n        \"id\": 0,\n        \"layer\": 0,\n        \"subnet\": 0\n      },\n      {\n        \"host\": {\n          \"compromised\": false,\n          \"compromisedServices\": [],\n          \"hostId\": 1,\n          \"hostUuid\": \"321663a6-13f5-4b2e-bb94-109b4a7b3899\",\n          \"ip\": \"169.179.214.27\",\n          \"osType\": \"centos\",\n          \"osVersion\": \"8\",\n          \"pUCompromise\": false,\n          \"totalNodes\": 8,\n          \"totalServices\": 7,\n          \"totalUsers\": 5\n        },\n        \"id\": 1,\n        \"layer\": 0,\n        \"subnet\": 0\n      },\n      ...\n    ]\n  }\n}\n</code></pre></li> <li>MTD Record <pre><code>{\n'name': {0: 'CompleteTopologyShuffle', 1: 'OSDiversity', 2: 'OSDiversity'},\n'start_time': {0: 0.0, 1: 200.3685748174762, 2: 400.9527232348661},\n'finish_time': {0: 121.81486938465021, 1: 280.6090999799783, 2: 481.0931564591807},\n'duration': {0: 121.81486938465021, 1: 80.24052516250208, 2: 80.14043322431462},\n'executed_at': {0: 'network', 1: 'application', 2: 'application'}\n}\n</code></pre></li> <li>Attack Record <pre><code>{\n'name': {0: 'SCAN_HOST', 1: 'ENUM_HOST', 2: 'SCAN_PORT'},\n'start_time': {0: 0.0, 1: 5.0, 2: 10.0}, \n'finish_time': {0: 5.0, 1: 10.0, 2: 35.0}, \n'duration': {0: 5.0, 1: 5.0, 2: 25.0},\n'current_host': {0: -1, 1: -1, 2: 0}, \n'current_host_uuid': {0: -1, 1: -1, 2: '1381b434-3f3b-4b8a-a0b8-3583742eea6c'}, \n'compromise_host': {0: 'None', 1: 'None', 2: 'None'}, \n'compromise_host_uuid': {0: 'None', 1: 'None', 2: 'None'}, \n'current_host_attempt': {0: 0, 1: 0, 2: 1}, \n'cumulative_attempts': {0: 0, 1: 0, 2: 0}, \n'cumulative_compromised_hosts': {0: 0, 1: 0, 2: 0}, \n'compromise_users': {0: [], 1: [], 2: []}, \n'interrupted_in': {0: 'None', 1: 'None', 2: 'None'}, \n'interrupted_by': {0: 'None', 1: 'None', 2: 'None'},\n} \n</code></pre></li> <li>Compromise checkpoint metrics <pre><code>[{\n'time_to_compromise': 2372.763291073691,\n'attack_success_rate': 0.38461538461538464,\n'host_compromise_ratio': 0.1,\n'mtd_execution_frequency': 0.005108120128305538\n}, \n{\n'time_to_compromise': 4009.0138625032932,\n'attack_success_rate': 0.40816326530612246,\n'host_compromise_ratio': 0.2,\n'mtd_execution_frequency': 0.005108120128305538\n}]\n</code></pre></li> </ul>"},{"location":"backend/endpoints/#response-elements","title":"Response Elements","text":"<ul> <li><code>network</code> contains the graph of the network from the _network object. The <code>host</code> element of the nodes in the graph have been converted to json for compatibility with the d3 library.</li> <li><code>mtd_record</code>and <code>attack_record</code> comprise the records of the total operation of the simulation, what attack and defense methods were utilised, as well as when and where.</li> <li><code>compromise_checkpoint_metrics</code> contains some of the key metrics of the simulation at particular percentages of compromise.</li> </ul>"},{"location":"backend/endpoints/#request-parameters","title":"Request Parameters","text":"<ul> <li><code>finishTime</code> is an optional parameter, if <code>finishTime</code> is not provided, the simulation runs till the network reaches compromised threshold (compromise ratio &gt; 0.9)<ul> <li>Stable test limit: <code>None</code> or 10 &lt;= <code>finishTime</code> &lt;= 5000</li> </ul> </li> <li><code>startTime</code> is the time to start the simulation<ul> <li>Stable test limit: <code>startTime</code> &gt;= 0</li> <li>Logical limit: <code>startTime</code> &lt;= <code>finishTime</code></li> </ul> </li> <li><code>mtdInterval</code> is the time imterval ot trigger MTD(s)<ul> <li>Stable test limit: <code>mtdInterval</code> &gt; 0; no apparent upward limit</li> <li>Logical limit: <code>mtdInterval</code> &lt;= <code>finishTime</code> - <code>startTime</code></li> </ul> </li> <li><code>scheme</code> is the mtd scheme to be used, please get available schemes from schemes endpoint TODO<ul> <li>Stable test limit: \"random\" or \"simultaneous\" or \"alternative\"; \"single\" and None produce error</li> </ul> </li> <li><code>totalNodes</code> is the number of nodes in the network (network size)<ul> <li>Stable test limit: 20 &lt;= <code>totalNodes</code> &lt;= 1000</li> </ul> </li> <li><code>seed</code> can be provided to replicate simulations.</li> <li><code>totalEndpoints</code> is the number of exposed nodes<ul> <li>Stable test limit: <code>totalEndpoints</code> &gt; 0 and <code>totalEndpoints</code> &lt; <code>totalNodes</code></li> </ul> </li> <li><code>totalSubnets</code> is the number of subnets<ul> <li>Logical limit: (<code>totalNodes</code> - <code>totalEndpoints</code>) / (<code>totalSubnets</code> - 1) &gt; 2</li> </ul> </li> <li><code>totalLayers</code> is the number of layers in the network<ul> <li>Stable test limit: 0 &lt; <code>totalLayers</code> &lt;= 12</li> <li>Input above 12 causes index error as mtdnetwork\\network.py loops through constant array of hosts</li> </ul> </li> <li><code>targetLayer</code> is the target layer in the network<ul> <li>No known limit causes error</li> </ul> </li> <li><code>totalDatabase</code> is the number of database nodes used for computing DAP algorithm<ul> <li>No known limit causes error</li> </ul> </li> <li><code>terminateCompromiseRatio</code> is the compromised ratio at which the simulation will terminate<ul> <li>Logical limit: 0.0 &lt; <code>terminateCompromiseRatio</code> &lt;= 1.0</li> </ul> </li> </ul>"},{"location":"deployment/api_deployment/","title":"API deployment","text":"<p>The API is deployed using Google Cloud Run following this documentation. Ensure that <code>gcloud</code> cli has been installed and you are able to authenticate yourself with the correct permissions</p> <p>To deploy:</p> <ol> <li>Change into the <code>server</code> directory</li> <li>run <code>gcloud run deploy</code></li> <li>set name to <code>mtd-sim-api</code>, this is the name of the service on the cloud console</li> <li>set region to <code>australia-southeast1</code></li> </ol>"},{"location":"deployment/electron/","title":"Electron","text":"<p>For our app verion we are using Electron Forge, this is a package that has been built by the Electron team that aims to make it easier to get applications up and running quicker.</p> <p>We have used this with Vite + Vue 3 to create a simple application that can be run on Windows, Mac and Linux.</p>"},{"location":"deployment/electron/#deployment-of-releases","title":"Deployment of releases","text":"<p>There is a GitHub action that has been written that will automate the building process on all platforms when code is pushed to the master branch. This will create a release and upload it to the github releases page. Please note that if an update is to occur you need to update the version number inside the <code>package.json</code> file.</p> <p>Note: as of 16th October 2023 GitHub has no free tier M1 machine running with arm that is able to be ran on GitHub actions.</p> <p>Currently there is an object that is specified inside the <code>forge.config.js</code> that will allow you to specify some properties of deployment.</p> <pre><code>publishers: [\n    {\n      name: \"@electron-forge/publisher-github\",\n      config: {\n        repository: {\n          owner: \"cits3200-team37\",\n          name: \"mtd\",\n        },\n        prerelease: true,\n      },\n    },\n  ]\n</code></pre> <p>Note the use of the prerelease flag, this is to ensure that when a release is pushed to GitHub it isnt automatically releases and needs to be signed off by the admin.</p>"},{"location":"deployment/github_pages/","title":"Github Pages","text":"<p>The documentation is been hosted on githubs own pages service. This is a static site that is generated from the markdown files in this directory. The site is generated using mkdocs. The theme used is material.</p> <p>We are currently using a Github Action to build and deploy the site. The action is defined in <code>.github/workflows/ci.yml</code>. The action is triggered on every push to the <code>main</code> branch. The action will build the site and push the changes to the <code>gh-pages</code> branch. The site is then hosted from the <code>gh-pages</code> branch.</p> <p>For more detailed information about deploying to Github Pages please refer to Material Theme Deployment.</p>"},{"location":"deployment/vercel/","title":"Vercel","text":"<p>For this project we are currently deploying the front end framework to Vercel. Vercel is a cloud platform for static sites and serverless functions.</p> <p>The setup is very easy once you have an account setup. Simply click the add new button and link your Github account. Select the repository you want to deploy and Vercel will automatically detect the framework and build the site. You can then configure the deployment settings and deploy the site.</p>"},{"location":"mtdnetwork/component/host/","title":"Host","text":""},{"location":"mtdnetwork/component/host/#description","title":"Description","text":"<p><code>host.py</code> contains the <code>Host</code> class.</p> <ul> <li> <p>It is used to initialise the host with the specified Operating Sytems with a random network of internal services that the host runs.</p> </li> <li> <p>The internal service network for the Host maps what services the hacker needs to compromise in order to compromise the entire Host.</p> </li> <li> <p>A host is said to be compromised if a service adjacent to the target node is compromised or the hacker has been able to obtain the password for a user on the Host.</p> </li> <li> <p>Parameters :</p> <ul> <li> <p><code>operating_system</code>: The operating system of the host</p> </li> <li> <p><code>os_version</code>: The OS version</p> </li> <li> <p><code>host_id</code>: The ID of the host on the graph of hosts</p> </li> <li><code>host_ip</code>:                 the IP address of the host</li> <li><code>users_list</code>: A tuple list of Users on the Host that also specify if the user reuses their password eg. if Josh is added to this host and they reused their pass then users_list would be [(\"Josh\", True)].</li> <li><code>network</code>: The Network instance of the simulation</li> <li><code>service_generator</code>: The ServiceGenerator instance for generating new services</li> <li><code>k_nearest_neighbors_percent</code>: The ratio for the k nearest neighbors when generating the internal graph using Watts-Strogatz random graph</li> <li><code>prob_strogatz_rewire</code>: The probability that an edge is rewired for the Watts-Strogatz random graph</li> </ul> </li> </ul> <p></p> <ul> <li> <p><code>is_exposed_endpoint</code> method:</p> <ul> <li>This method checks if the endpoint is exposed</li> </ul> </li> <li> <p><code>__eq__</code> method:</p> </li> <li> <ul> <li>This method is used to compare two Host objects for equality based on their uuid attributes.</li> </ul> </li> <li><code>get_all_services</code> method:<ul> <li>This method returns all the services</li> </ul> </li> <li><code>get_test_values</code> method:<ul> <li>This method returns all the services</li> </ul> </li> <li><code>get_total_nodes</code> method:<ul> <li>This method returns total number of nodes</li> </ul> </li> <li><code>get_all_vuln</code> method:<ul> <li>This method returns a list of the vulnerabilities</li> </ul> </li> <li><code>get_vulns_for_list</code> method:<ul> <li>This method retreives vulnerabilities for a given list</li> </ul> </li> <li><code>swap_network</code> method:<ul> <li>This method swaps the network</li> </ul> </li> <li><code>setup_network</code> method:<ul> <li>This method sets up the network configuration for the host</li> </ul> </li> <li> <p><code>set_compromised</code> method:</p> <ul> <li>This methods sets the host as compromised </li> </ul> </li> <li> <p><code>possible_user_compromise</code> method:</p> <ul> <li>This method returns true if there is a user on the host that has reused their password.</li> </ul> </li> <li> <p><code>can_auto_compromise_with_users</code> method:</p> <ul> <li>This method creates an action where the adversary tries to compromise the host using a reused password and returns an action that will return if the adversary was succesfully in finding a user with a reused password</li> <li>Parameters:<ul> <li>compromised_users: a list of users the adversary has compromised</li> </ul> </li> </ul> </li> <li> <p><code>is_compromised</code> method:</p> <ul> <li>This method return if the host is compromised </li> </ul> </li> <li> <p><code>compromise_with_users</code> method:</p> <ul> <li>This method tries to brute force a login using the list of users that the adversary has compromised and returns and action if the brute force worked</li> <li>Parameters:<ul> <li><code>compromised_users</code>: the list of users the hacker has compromised</li> </ul> </li> </ul> </li> <li> <p><code>get_service_and_vulns</code> method:</p> <ul> <li>This method returns a dictionary of all non-target nodes and their vulnerabilities</li> </ul> </li> <li> <p><code>get_target_node</code> method:</p> <ul> <li>This method is used to get the target node</li> </ul> </li> <li> <p><code>get_exposed_nodes</code> method:</p> <ul> <li>This  method is used to get the exposed nodes</li> </ul> </li> <li> <p><code>remove_no_vuln_nodes</code> method:</p> <ul> <li>This method removes all service nodes with no vulnerabilities </li> </ul> </li> <li> <p><code>get_services</code> method:</p> <ul> <li>This method gets the services on the host and returns a dictionary where the key is the ID and the value is the Service instance</li> <li>Parameters:<ul> <li><code>just_exploited</code>: The services that have been exploited</li> </ul> </li> </ul> </li> <li> <p><code>get_services_from_list</code> method:</p> <ul> <li>This method gets Service instance from a list of service numbers of host</li> </ul> </li> <li> <p><code>get_services_from_ports</code> method:</p> <ul> <li>This method is used to get the services from the discovered ports</li> </ul> </li> <li> <p><code>port_scan</code> method:</p> <ul> <li>This method is used to scan a port</li> </ul> </li> <li> <p><code>get_vulns</code> method</p> <ul> <li>This method gets the possible vulnerabilities on the Host based on the discovered port numbers and returns a hacer action for discovering if the vulnerabilities are present on the host and a possible method of exploitation</li> <li>Parameters:<ul> <li><code>discovered_service_ports</code>: a list of ports found open doing a port scan</li> <li><code>ignore_services</code>: the list of service IDs to ignore when searching for vulnerabilities</li> <li><code>roa_threshold</code>: the return of attack (RoA) threshold that the adversary users for sorting the exploits they want to use</li> </ul> </li> </ul> </li> <li> <p><code>check_compromised</code> method:</p> <ul> <li>This method checks if the current host is compromised</li> </ul> </li> <li> <p><code>discover_neighbors</code> method:</p> <ul> <li>This method scans for neighbours of the host and returns an action that returns a list of neighbouring host ids.</li> <li> <p><code>get_ports</code> method:</p> </li> <li> <p>This method returns all the ports on he host</p> </li> </ul> </li> <li> <p><code>get_ports_for_services</code> method:</p> <ul> <li>This methods is used to get a list of ports associated with specified services</li> </ul> </li> <li> <p><code>get_os_type_and_version</code> method:</p> <ul> <li>This method is used to get the OS type and version</li> </ul> </li> <li> <p><code>get_compromised_users</code> method:</p> <ul> <li>This method is used to retreive a list of compromised users.</li> </ul> </li> <li> <p><code>get_users</code> method:</p> <ul> <li>This method is used to retreive a list of users </li> </ul> </li> <li> <p><code>change_node_color</code> method:</p> <ul> <li>This  method changes the color of the host on the overall network</li> </ul> </li> <li> <p><code>set_host_users</code> method:</p> <ul> <li>This method sets the users on the host.</li> <li>Parameters:<ul> <li><code>users_list</code>: The tuple users lists specifying the username and if the user reuses their password</li> </ul> </li> </ul> </li> <li> <p><code>graph_choose_target_and_exposed</code> method:</p> <ul> <li>This method chooses the target and exposed services on the internal network.TThe exposed services means that an adversary can see the ports open externally</li> <li>Parameters:<ul> <li><code>graph</code>: The graph that is being generated.</li> <li><code>target_distance</code>: The target distance from the target node for exposed services.</li> </ul> </li> </ul> </li> <li> <p><code>get_exposed_endpoints</code> method:</p> <ul> <li>This method is used to get the exposed endpoints.</li> </ul> </li> <li> <p><code>gen_internal_network</code> method:</p> <ul> <li>This method is used to generate the internal network.</li> </ul> </li> <li> <p><code>draw</code> method:</p> <ul> <li>This method is used to draw the internal network for the host</li> </ul> </li> <li> <p><code>get_random_os_version</code> method:</p> <ul> <li>This method gets a random Operating System version.The latest versions are more likely to be chosen over older and outdated OS versions.</li> <li>Parameters:<ul> <li><code>operating_system</code>: The name of the operating_system to pick a random version for.</li> </ul> </li> </ul> </li> <li> <p><code>get_random_os</code> method:</p> <ul> <li>This method returns a random OS</li> </ul> </li> <li> <p><code>get_random_address</code> method:</p> <ul> <li>This method gets a Random IPv4 address and makes sure that one does not already exist.</li> <li>Parameters:      -<code>existing_addresses</code>: A list of already allocated IP addresses on the network</li> </ul> </li> <li> <p><code>get_random_port</code> method:</p> <ul> <li>This method gets a random port while checking a port has already been allocated for a host.</li> <li>Parameters:<ul> <li><code>existing_ports</code>: The port numbers that have already been allocated to the host</li> </ul> </li> </ul> </li> <li> <p><code>get_path_from_exposed</code> method:</p> <ul> <li>This method gets the shortest path and distance from the exposed endpoints and returns a tuple where the first element is the shortest path and the second element is the distance</li> </ul> </li> <li> <p><code>to_json</code> method:</p> <ul> <li>This method converts host attributes to a JSON representation</li> </ul> </li> </ul>"},{"location":"mtdnetwork/component/host/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/data/constants</li> <li>import mtdnetwork/component/services</li> <li>import mtdnetwork/component/time_network </li> </ul>"},{"location":"mtdnetwork/component/mtd_scheme/","title":"MTDScheme Class","text":""},{"location":"mtdnetwork/component/mtd_scheme/#description","title":"Description","text":"<p>The <code>MTDScheme</code> class encapsulates the logic for different Moving Target Defense (MTD) schemes in a network environment. This class defines various MTD strategies, manages the registration and triggering of these strategies, and handles the suspension and activation of specific MTD techniques.</p>"},{"location":"mtdnetwork/component/mtd_scheme/#initialization","title":"Initialization","text":"<ul> <li> <p>Parameters:</p> <ul> <li><code>scheme</code>: Specifies how MTDs are executed and can be done in <code>alternatively</code>, <code>simultaneously</code>, or <code>randomly</code>.</li> <li><code>network</code>: Refers to the simulation network.</li> <li><code>mtd_trigger_interval</code> (optional): The time interval to trigger MTD strategies. Defaults to None.</li> <li><code>mtd_trigger_std</code> (optional): Standard deviation for the trigger interval. Defaults to 0.5.</li> <li><code>custom_strategies</code> (optional): Custom MTD priority strategies for alternative or single schemes. Defaults to None.</li> </ul> </li> <li> <p><code>_mtd_register_scheme</code>: A method that determines how MTD strategies are registered based on the chosen scheme.</p> </li> <li><code>_mtd_strategies</code>: A default list of available MTD strategies. <code>CompleteTopologyShuffle</code>, <code>IPShuffle</code>, <code>OSDiversity</code>, and <code>ServiceDiversity</code>.</li> </ul>"},{"location":"mtdnetwork/component/mtd_scheme/#methods","title":"Methods","text":"<p><code>_init_mtd_scheme(scheme)</code>:</p> <ul> <li>Initializes the MTD scheme based on the provided <code>scheme</code>: <code>simultaneous</code>, <code>random</code>, <code>alternative</code> or <code>single</code>. This method sets the registration function for the MTD scheme. WARN: simultaneous and single scheme do not work</li> </ul> <p><code>_mtd_register(mtd)</code>:</p> <ul> <li>Registers a given MTD strategy to the network's queue. If the MTD passed is a class type, it instantiates it. The MTD strategy is paired with its priority and pushed onto the network's MTD queue.</li> </ul> <p><code>_register_mtd_simultaneously()</code>:</p> <ul> <li>Registers all custom MTD strategies for simultaneous execution.</li> </ul> <p><code>_register_mtd_randomly()</code>:</p> <ul> <li>Randomly selects and registers an MTD strategy from the custom strategies list.</li> </ul> <p><code>_register_mtd_alternatively()</code>:</p> <ul> <li>Registers custom MTD strategies in an alternative sequence.</li> </ul> <p><code>_register_mtd_single()</code>:</p> <ul> <li>Registers a single custom MTD strategy.</li> </ul> <p><code>trigger_suspended_mtd()</code>:</p> <ul> <li>Triggers the MTD strategy with the minimum priority from the suspended list</li> </ul> <p><code>trigger_mtd()</code>:</p> <ul> <li>Triggers the MTD strategy with the highest-priority from the network's MTD queue.</li> </ul> <p><code>suspend_mtd(mtd_strategy)</code>:</p> <ul> <li>Suspends a given MTD strategy, adding it to the network's suspended list based on its priority.</li> </ul> <p><code>register_mtd()</code>:</p> <ul> <li>Calls the appropriate MTD register scheme function based on the initialized scheme.</li> </ul> <p>Getter Methods: <code>get_scheme()</code>:</p> <ul> <li>Returns the MTD scheme type.</li> </ul> <p><code>get_mtd_trigger_interval()</code>:</p> <ul> <li>Returns the MTD trigger interval.</li> </ul> <p><code>get_mtd_trigger_std()</code>:</p> <ul> <li>Returns the standard deviation for the MTD trigger interval.</li> </ul> <p>Setter Methods:</p> <p><code>set_mtd_strategies(mtd)</code>:</p> <ul> <li>Sets the MTD strategies list with the given strategies.</li> </ul>"},{"location":"mtdnetwork/component/mtd_scheme/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/mtd/completetopologyshuffle</li> <li>mtdnetwork/mtd/ipshuffle</li> <li>mtdnetwork/mtd/osdiversity</li> <li>mtdnetwork/mtd/servicediversity</li> <li>mtdnetwork/data/constants</li> </ul>"},{"location":"mtdnetwork/component/network/","title":"Network Base Class","text":"<p><code>network.py</code> is the basic network class, serving as the basis for all network super classes in the simulation.</p>"},{"location":"mtdnetwork/component/network/#description","title":"Description","text":"<p>The <code>network</code> class is a data representation of a target network. It includes the basic attributes of networks and the methods to generate, update and manipulate it. This class serves as the basis on which the simulation is run.</p>"},{"location":"mtdnetwork/component/network/#initialization","title":"Initialization","text":"<ul> <li> <p>Parameters:</p> <ul> <li><code>total_nodes</code>: The number of nodes in the network.</li> <li><code>total_endpoints</code>: The number of nodes exposed on the internet (hacker can interact directly with them).</li> <li><code>total_endpoints</code> must be less than total_nodes.</li> <li><code>total_subnets</code>: The number of sub-networks in the network</li> <li><code>total_layers</code>: The number of layers deep the network structures goes from the exposed endpoints.</li> <li><code>total_database</code>: The total size of the simulated database</li> <li><code>target_layer</code>: Sets the target layer where a target node will be selected.</li> <li><code>user_to_nodes_ratio</code>: The percent of users in comparison to host machines.             each node will then be given <code>int(1/user_to_nodes_ratio)</code> users each (less users more users on each computer).</li> <li><code>prop_user_reuse_pass</code>: The probability that a user has reused their password.</li> </ul> </li> <li> <p>Properties:</p> <ul> <li><code>graph</code>: The network as a graph from the networkx library.</li> <li><code>colour_map</code>: A mapping of colours from constants.py to nodes based on sub-network.</li> <li><code>users_per_host</code>: The number of users per host on a node.</li> <li><code>total_users</code>: The total number of users.</li> <li><code>users_list</code>: A list of users.</li> <li><code>pos</code>: A dictionary of positions of items in the networks subgraphs.</li> <li><code>_database</code>: A list of the \"database\" containing values from <code>(total_nodes - total_database -&gt; total_nodes)</code>.</li> <li><code>tags</code>: A list of Host tags from constants.py assigned to the networks layers.</li> <li><code>tag_priority</code>: An ordered list of tags by priority.</li> <li><code>service_generator</code>: A service_generator object from services.py.</li> <li><code>nodes</code>: A list of the nodes from total_nodes.</li> <li><code>mtd_strategies</code>: A list of mtd_strategies.</li> <li><code>reachable</code>: A list of reachable nodes.</li> <li><code>compromised_hosts</code>: A list of compromised hosts.</li> <li><code>node_per_layer</code>: A list of the number of nodes per layer.</li> <li><code>network_type</code>: An int specifying the attack type. 0 for targetted, 1 for general (no target node).</li> <li><code>vuln_dict</code>: A dictionary of Hosts and their vulnerabilities.</li> <li><code>vuln_count</code>: A dictionary vulnerabilities and their frequency in the network.</li> <li><code>service_dict</code>: A dictionary of hosts and their available services.</li> <li><code>service_count</code>: A dictionary of services and their frequency in the network.</li> <li><code>total_vuln</code>: The total number of vulnerabilities among hosts.</li> <li><code>total_services</code>: The total number of services among hosts.</li> <li><code>scorer</code>: A scorer object from <code>mtdnetwork.statistic.scorer</code>.</li> <li><code>target_node</code>: A target node for an attack.</li> </ul> </li> </ul>"},{"location":"mtdnetwork/component/network/#methods","title":"Methods","text":"<ul> <li> <p><code>init_network()</code>:     initializes the network with its additional properties. Assigns tags, tag priority and users. Creates and sets up the network graph. Sets initial statistics.</p> </li> <li> <p><code>update_host_information()</code>:     Updates hosts networks to be itself.</p> </li> <li> <p><code>gen_graph()</code>:</p> <p>Generates a network of subnets using the Barabasi-Albert Random Graph model.</p> <ul> <li>Parameters:<ul> <li><code>min_nodes_per_subnet</code>: The minimum number of computer nodes for each subnet. Default = 2.</li> <li><code>max_subnets_per_layer</code>: The maximum number of subnets per layer. Default = 5.</li> <li><code>subnet_m_ratio</code>: A ratio that is used to determine the parameter m for the barabasi albert graph. m is the number of edges to attach from a new node to existing nodes. Default = 0.2.</li> <li><code>prob_inter_layer_edge</code>: The probability that a node connects to a different layer in the network. Default = 0.4.</li> </ul> </li> </ul> </li> <li> <p><code>add_attack_path_exposure()</code>:     Adds the Attack Path Exposure Score to statistics.</p> </li> <li> <p><code>attack_path_exposure()</code>:     Gets the total attack path exposure, scoring each node based on the % of new vulnerabilities found in each node on the shortest path to the target_node out of 1.</p> <ul> <li>Returns:<ul> <li>ave_score: Score of each host added up, divided by the number of hosts.</li> </ul> </li> </ul> </li> <li> <p><code>setup_users()</code>:     Randomly generates users that use the network.</p> <ul> <li>Parameters:<ul> <li><code>user_to_nodes_ratio</code>:         the percent of users in comparison to host machines.         each node will then be given <code>int(1/user_to_nodes_ratio)</code> users each (less users more users on each computer).</li> <li><code>prob_user_reuse_pass</code>:         the probability that a user has reused their password.</li> <li><code>users_per_host</code>:         how many users are allocated to each host on the network.</li> </ul> </li> </ul> </li> <li> <p><code>update_reachable_mtd()</code>:     Updates the Reachable array with only compromised nodes that are reachable after MTD.</p> </li> <li> <p><code>update_reachable_compromise()</code>:     Updates the Reachable with the node_id of the compromised node.</p> <ul> <li>Parameters:<ul> <li><code>compromised_node_id</code>: id of the compromised node.</li> <li><code>compromised_hosts</code>: currently compromised hosts.</li> </ul> </li> </ul> </li> <li> <p><code>assign_tags()</code>:      Assigns the tags to layers from constants.py.</p> </li> <li> <p><code>assign_tag_priority()</code>:     Orders tags based on priority.</p> </li> <li> <p><code>sort_by_distance_from_exposed_and_pivot_host()</code>:     Sorts the Host Stack by the shortest number of hops to reach the target hosts.</p> <ul> <li>Parameters:<ul> <li><code>host_stack</code>:     a list of host IDs the attacker wants to attack.</li> <li><code>compromised_hosts</code>:     a list of host IDs the hacker has compromised.</li> <li><code>pivot_host_id</code>:     the ID of the host that is compromised that the hacker is using to pivot from. if None then it only sorts by the exposed endpoints. Default = -1 (no pivot)</li> </ul> </li> </ul> </li> <li> <p><code>setup_network()</code>:     Using the generated graph, generates a host for each node on the graph.</p> </li> <li> <p><code>is_target_compromised()</code>:     Checks if the target node compromised.</p> <ul> <li>Returns:     boolean.</li> </ul> </li> <li> <p><code>is_compromised()</code>:     Checks if the Network has been completely compromised.</p> <ul> <li> <p>Parameters:     <code>compromised_hosts</code>:         the list of host IDs that have been compromised by the hacker.</p> </li> <li> <p>Returns:         boolean.</p> </li> </ul> </li> </ul> <p>Getter Methods:</p> <ul> <li><code>get_total_endpoints()</code>: Returns total endpoints.</li> <li><code>get_exposed_endpoints()</code>: Returns exposed endpoints.</li> <li><code>get_database()</code>: Returns database.</li> <li><code>get_total_database()</code>: Returns total database.</li> <li><code>get_scorer()</code>: Returns scorer.</li> <li><code>get_statistics()</code>: Returns statistics from scorer.</li> <li><code>get_service_generator()</code>: Returns service generator.</li> <li><code>get_hosts()</code>: Returns hosts.</li> <li><code>get_subnets()</code>: Returns subnets.</li> <li><code>get_layers()</code>: Returns layers.</li> <li><code>get_graph()</code>: Returns the network graph.</li> <li><code>get_graph_copy()</code>: Returns a copy of the network graph.</li> <li><code>get_pos()</code>: Returns pos (positions).</li> <li><code>get_colourmap()</code>: Returns colour_map.</li> <li><code>get_total_nodes()</code>: Returns total nodes.</li> <li><code>get_network_type()</code>: Returns network type.</li> <li><code>get_unique_subnets()</code>: Returns unique subnets.</li> <li><code>get_reachable()</code>: Returns reachable nodes.</li> <li><code>get_nodes_per_layer()</code>: Returns nodes per layer.</li> <li><code>get_users_list()</code>: Returns users list.</li> <li><code>get_users_per_host()</code>: Returns users per host.</li> <li> <p><code>get_host_id_priority()</code>:      Assign priority of host_id based on layer</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>host_id</code>: node id of the desired node</li> </ul> </li> <li> <p>Returns:     <code>Priority</code>: An integer based on tag_priority array, with target node scoring 0, top priority node scoring 1, and subsequent nodes scoring 1 higher.</p> </li> <li><code>get_path_from_exposed()</code>: Gets the shortest path and distance from the exposed endpoints.</li> </ul> <p>Can also specify a subgraph to use for finding.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>target_node</code>:     the target node to reach.</li> <li><code>graph</code>:     subgraph of containing target. Default = <code>None</code>.</li> </ul> </li> <li> <p>Returns:         a tuple where the first element is the shortest path and the second element is the distance</p> </li> </ul> </li> <li> <p><code>get_shortest_distance_from_exposed_or_pivot()</code>:      Gets shortest distance to host from exposed hosts or a pivot host using get_path_from_exposed().</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>host_id</code>:     the target node to reach.</li> <li><code>pivot_host_id</code>:     id of the pivot host. Default = -1 (no pivot)</li> <li><code>graph</code>:     subgraph of containing target. Default = <code>None</code>.</li> </ul> </li> <li> <p>Returns:     Shortest distance.</p> </li> <li> <p><code>get_neighbors()</code>: Returns the neighbours for a host.</p> </li> <li> <p>Parameters:</p> <ul> <li><code>host_id</code>:     the host ID to get the neighbors from</li> </ul> </li> <li> <p>Returns:     a list of the neighbors for the host.</p> </li> <li><code>get_hacker_visible_graph()</code>: Returns the Network graph that is visible to the hacker depending on the hosts that have already been compromised.</li> </ul> </li> <li> <p><code>get_host()</code>:     Gets the Host instance based on the host_id</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>host_id</code>: the ID of the Host Instance</li> </ul> </li> <li> <p>Returns:     the corresponding Host instance</p> </li> <li><code>get_total_vulns()</code>: Returns total vulnerabilities.</li> <li> <p><code>get_vuln_dict()</code>:  Gets all the vulnerabilities for every hosts and puts them in vuln_dict</p> </li> <li> <p>Returns:     <code>vuln_count</code>: the frequency of every vuln</p> </li> <li><code>get_total_services()</code>: Returns total services.</li> <li> <p><code>get_service_dict()</code>: Gets all the services for every hosts and puts them in service_dict</p> </li> <li> <p>Returns:</p> <ul> <li><code>service_count</code>: the freuqency of every service</li> </ul> </li> </ul> </li> </ul>"},{"location":"mtdnetwork/component/network/#dependencies","title":"Dependencies","text":"<pre><code>networkx\npkg_resources\nmatplotlib/pyplot\nnumpy\nrandom\nos\nmtdnetwork/data/constants\nmtdnetwork/component/services\nmtdnetwork/component/host\nmtdnetwork/statistic/scorer\n</code></pre>"},{"location":"mtdnetwork/component/service/","title":"Service Class","text":""},{"location":"mtdnetwork/component/service/#vulnerability-class","title":"Vulnerability Class","text":""},{"location":"mtdnetwork/component/service/#description","title":"Description","text":"<p>The <code>Vulnerability</code> class defines a vulnerability's properties such as its complexity, impact, and associated CVSS score. It also handles certain behaviors like calculating the time required to exploit the vulnerability and determining if it has been exploited.</p>"},{"location":"mtdnetwork/component/service/#initialization","title":"Initialization","text":"<ul> <li> <p>Parameters:</p> <ul> <li><code>can_have_os_dependency</code> (optional): Specifies if the vulnerability can have an OS dependency. Defaults to False.</li> <li><code>os_list</code> (optional): A list of operating systems that the vulnerability might be applicable to, depending on the service.</li> </ul> </li> <li> <p><code>complexity</code>: A float value (between <code>VULN_MIN_COMPLEXITY</code> and 1) representing how hard it is to exploit this vulnerability, with 1 being easy and 0 being impossible.</p> </li> <li><code>impact</code>: A float value (between 0 and 10) representing the severity of successfully exploiting this vulnerability.</li> </ul>"},{"location":"mtdnetwork/component/service/#methods","title":"Methods","text":"<p><code>is_exploited</code>:</p> <ul> <li>Return if the vulnerability has been exploited.</li> </ul> <p><code>get_id</code>:</p> <ul> <li>Return the unique identifier of the vulnerability.</li> </ul> <p><code>can_exploit_with_dependent_vuln</code>:</p> <ul> <li>checks if there is another vulnerability in the provided list that, when exploited, can enable the exploitation of the current vulnerability. The function return True if such a vulnerability exists in <code>vulns</code> or if the current vulnerability has no dependencies.</li> </ul> <p><code>exploit_time</code>:</p> <ul> <li>Calculates the time required to exploit this vulnerability. This estimate is influenced by the vulnerability's complexity, its potential operating system dependency, and whether it's already been exploited.</li> </ul> <p><code>network</code>:</p> <ul> <li>Tries to exploit the vulnerability. If the vulnerability has already been exploited, it returns the impact score directly. Otherwise, it checks factors like complexity and operating system dependencies to determine the success of the exploitation. The method either returns the impact score upon successful exploitation or 0.0 if the attempt fails. It returns the impact score upon successful exploitation or 0.0 if the attempt fails.</li> </ul> <p><code>roa</code>:</p> <ul> <li>Computes a pseudo \"return on attack\" metric that assesses the potential gain of an attack in relation to its cost, using the exploit time as the cost</li> </ul> <p><code>initial_roa</code>:</p> <ul> <li>Calculates the initial \"return on attack\" metric using a predefined minimum exploit time.</li> </ul> <p><code>__eq__</code>:</p> <ul> <li>Determines if two instances of the Vulnerability class are equal based on their unique IDs.</li> </ul>"},{"location":"mtdnetwork/component/service/#service-class_1","title":"Service Class","text":""},{"location":"mtdnetwork/component/service/#description_1","title":"Description","text":"<p>The <code>Service</code> class encapsulates properties related to a particular software service, including its name, version, and associated vulnerabilities. The class provides methods for accessing vulnerabilities based on specific criteria and assessing whether the service has been exploited based on its vulnerabilities.</p>"},{"location":"mtdnetwork/component/service/#initialization_1","title":"Initialization","text":"<ul> <li> <p>Parameters:</p> <ul> <li><code>service_name</code>: The name of the service.</li> <li><code>service_version</code>: The version of the service.</li> <li><code>vulnerabilities</code>: A list of vulnerabilities associated with the service.</li> </ul> </li> <li> <p><code>exploit_value</code>: Initialized to 0.0, it represents the accumulated impact of exploited vulnerabilities on the service.</p> </li> <li><code>id</code>: A unique identifier for the service instance.</li> </ul>"},{"location":"mtdnetwork/component/service/#methods_1","title":"Methods","text":"<p><code>copy</code>:</p> <ul> <li>Return a new <code>Service</code> instance that is a copy of the current instance, including its name, version, and vulnerabilities.</li> </ul> <p><code>get_vulns</code>:</p> <ul> <li>Provides the top vulnerabilities of the service based on their RoA values, excluding already exploited vulnerabilities. It can optionally take a RoA threshold and return only those vulnerabilities with a RoA greater than the threshold. By default, it returns a maximum of <code>SERVICE_TOP_X_VULNS_TO_RETURN</code> vulnerabilities.</li> </ul> <p><code>get_all_vulns</code>:</p> <ul> <li>Return the complete list of vulnerabilities associated with the service.</li> </ul> <p><code>get_id</code>:</p> <ul> <li>Return the unique identifier of the service instance.</li> </ul> <p><code>is_exploited</code>:</p> <ul> <li>Determines if the service has been exploited by evaluating the sum of the impact values of its exploited vulnerabilities. The service is considered exploited if this sum exceeds the <code>SERVICE_COMPROMISED_THRESHOLD</code>.</li> </ul> <p><code>discover_vuln_time</code>:</p> <ul> <li>Calculates the time required to discover vulnerabilities in the service based on the number of vulnerabilities surpassing a given RoA threshold. It uses the constant <code>SERVICE_DISCOVER_EACH_VULN_TIME</code> to determine the discovery time for each vulnerability.</li> </ul> <p><code>get_highest_roa_vuln</code>:</p> <ul> <li>Return the RoA value of the top vulnerability of the service in terms of RoA, or 0.0 if there are no vulnerabilities that meet the criteria.</li> </ul> <p><code>__eq__</code>:</p> <ul> <li>Compares the current <code>Service</code> instance with another object to determine equality. Two services are considered equal if they have the same name and version.</li> </ul>"},{"location":"mtdnetwork/component/service/#servicesgenerator-class","title":"ServicesGenerator Class","text":""},{"location":"mtdnetwork/component/service/#description_2","title":"Description","text":"<p>The <code>ServicesGenerator</code> class is responsible for generating services for the simulation. It determines the distribution of services across various operating systems, models vulnerabilities for each service, and calculates the compatibility of services with different OS versions.</p>"},{"location":"mtdnetwork/component/service/#initialization_2","title":"Initialization","text":"<ul> <li>Parameters:<ul> <li><code>services_per_os</code> (optional): The number of services assigned to each OS. Defaults to <code>constants.SERVICE_NO_OF_SERVICES_PER_OS</code>.</li> <li><code>percent_cross_platform</code> (optional): Percent of services available across all platforms. Defaults to <code>constants.VULN_PERCENT_CROSS_PLATFORM</code>.</li> <li><code>max_vuln_probability</code> (optional): Maximum probability for older service versions having a vulnerability. Defaults to <code>constants.VULN_MAX_PROB_FOR_OCCURING_FOR_SERVICE_VERSION</code>.</li> <li><code>vuln_patch_mean</code> (optional): Average number of versions it takes for a vulnerability to be patched. Defaults to <code>constants.VULN_PATCH_MEAN</code>.</li> <li><code>vuln_patch_range</code> (optional): Range from the <code>vuln_patch_mean</code>. Defaults to <code>constants.VULN_PATCH_RANGE</code>.</li> <li><code>vuln_initial_chances</code> (optional): For the first service version, it iterates <code>vuln_initial_chances</code> times, testing if the first service gets a new vulnerability. Defaults to <code>constants.VULN_INITIAL_CHANCES</code>.</li> <li><code>os_dependent_vuln_chance</code> (Unused): Probability of a vulnerability being enabled only on a specific OS (if the service is available across platforms). Defaults to <code>constants.VULN_PROB_DEPENDS_ON_OS</code>.</li> <li><code>dependent_vuln_chance</code> (Unused): Chance that a vulnerability can be exploited only if there's another specific type of vulnerability present. Defaults to <code>constants.VULN_PROB_DEPENDS_ON_OTHER_VULNS</code>.</li> </ul> </li> </ul>"},{"location":"mtdnetwork/component/service/#methods_2","title":"Methods","text":"<p><code>get_random_service</code>:</p> <ul> <li>Selects a random service for a specified OS type and version and returns it.</li> </ul> <p><code>get_random_service_latest_version</code>:</p> <ul> <li>Fetches a random service, set to the latest version for the given OS type and version.</li> </ul> <p><code>service_is_compatible_with_os</code>:</p> <ul> <li>Checks if a service is compatible with a particular OS type and version. Returns True if compatible, False otherwise.</li> </ul> <p><code>gen_services</code>:</p> <ul> <li>This method is responsible for generating services, their associated vulnerabilities, and distributing them across different operating system types and versions.</li> </ul> <p><code>get_service_name_list</code>:</p> <ul> <li>Static method. Retrieves a list of service names.</li> </ul> <p><code>get_all_generated_services</code>:</p> <ul> <li>Fetches all the generated services for the simulation.</li> </ul>"},{"location":"mtdnetwork/component/service/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/data/constants</li> </ul>"},{"location":"mtdnetwork/mtd/completetopologyshuffle/","title":"Complete Topology Shuffle","text":"<p><code>completetopologyshuffle.py</code> contains the <code>CompleteTopologyShuffle</code> class, a subclass of <code>MTD</code>.</p>"},{"location":"mtdnetwork/mtd/completetopologyshuffle/#description","title":"Description","text":"<p>The <code>CompleteTopologyShuffle</code> class is designed to completely regenerate the network graph while preserving the hosts from the previous state. This approach enhances unpredictability for potential adversaries by drastically altering the network structure.</p>"},{"location":"mtdnetwork/mtd/completetopologyshuffle/#initialization","title":"Initialization","text":"<ul> <li>Parameters:<ul> <li><code>network</code> (optional): Specifies the network to be reshuffled. Expected to be an instance of a network class. Defaults to None.</li> </ul> </li> </ul>"},{"location":"mtdnetwork/mtd/completetopologyshuffle/#methods","title":"Methods","text":"<p><code>mtd_operation</code>:</p> <ul> <li>This method regenerates the network graph and integrates the previously existing hosts into the reshuffled network. The method updates reachable MTDs.</li> <li>If the network is targeted (i.e., <code>get_network_type() == 0</code>), then the Attack Path Exposure Score is added to statistics for future use</li> <li>Parameters:<ul> <li><code>adversary</code> (optional): Defaults to None and the code does not seem to use it</li> </ul> </li> </ul>"},{"location":"mtdnetwork/mtd/completetopologyshuffle/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/mtd</li> </ul>"},{"location":"mtdnetwork/mtd/hosttopologyshuffle/","title":"Complete Topology Shuffle","text":"<p><code>hosttopologyshuffle.py</code> contains the <code>HostTopologyShuffle</code> class, a subclass of <code>MTD</code>.</p>"},{"location":"mtdnetwork/mtd/hosttopologyshuffle/#description","title":"Description","text":"<p>The HostTopologyShuffle class provides functionality to swap hosts within the network. This shuffle introduces unpredictability to potential adversaries by altering the positions of hosts within the network's structure.</p>"},{"location":"mtdnetwork/mtd/hosttopologyshuffle/#initialization","title":"Initialization","text":"<ul> <li>Parameters:</li> <li><code>network</code> (optional): Specifies the network to be reshuffled. Expected to be an instance of a network class. Defaults to None.</li> </ul>"},{"location":"mtdnetwork/mtd/hosttopologyshuffle/#methods","title":"Methods","text":"<p><code>random_different_host_id</code>:</p> <ul> <li>This function provides a randomly chosen host ID from a list that is different from the given current host ID.</li> <li>Parameters:<ul> <li><code>curr_host_id</code>: Current host's ID.</li> <li><code>hosts_list</code>: A list of host IDs.</li> </ul> </li> </ul> <p><code>mtd_operation</code>:</p> <ul> <li>This method conducts the host shuffle operation by swapping the host IDs between different nodes in the network graph. While doing this, it ensures that exposed endpoints remain unaffected. </li> <li>After the shuffle, the method updates reachable MTDs</li> <li>If the network is targeted (i.e., <code>get_network_type() == 0</code>), then the Attack Path Exposure Score is added to statistics for future use</li> <li>Parameters:<ul> <li><code>adversary</code> (optional): Defaults to None and the code does not seem to use it</li> </ul> </li> </ul>"},{"location":"mtdnetwork/mtd/hosttopologyshuffle/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/mtd</li> </ul>"},{"location":"mtdnetwork/mtd/ipshuffle/","title":"IP Shuffle","text":""},{"location":"mtdnetwork/mtd/ipshuffle/#description","title":"Description","text":"<p>ipshuffle.py contains the <code>IPShuffle</code> class, a subclass of <code>MTD</code>.</p> <ul> <li>IP Shuffle is an MTD strategy that dynamically switches IP addresses of hosts to improve network security (e.g., it invalidates IP address collection by attacker)</li> <li>Takes an optional <code>network</code> parameter, which the MTD strategy can be applied to</li> </ul> <p> <code>mtd_operation</code> method</p> <ul> <li>Shuffles IP of host to a random address, if host is not an exposed endpoint</li> <li>Takes an optional <code>adversary</code> parameter, however the code does not seem to use it</li> </ul>"},{"location":"mtdnetwork/mtd/ipshuffle/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/mtd</li> <li>mtdnetwork/component/host</li> </ul>"},{"location":"mtdnetwork/mtd/mtdinit/","title":"MTD Base Class","text":"<p><code>__init__.py</code> introduces the foundational <code>MTD</code> class, serving as the base for all Moving Target Defense (MTD) strategies in the network.</p>"},{"location":"mtdnetwork/mtd/mtdinit/#description","title":"Description","text":"<p>The <code>MTD</code> class is a generic representation of an MTD strategy. It includes essential attributes and methods that any MTD strategy should use. This base class is crucial for maintaining a consistent structure and interface across different MTD strategies.</p>"},{"location":"mtdnetwork/mtd/mtdinit/#initialization","title":"Initialization","text":"<ul> <li>Parameters:<ul> <li><code>name</code>: Name of the MTD strategy.</li> <li><code>mtd_type</code>: Categorized either as \"shuffle\" or \"diversity\".</li> <li><code>resource_type</code>: Defines whether the MTD is related to an \"application\", \"network\", or is in \"reserve\".</li> <li><code>network</code> (optional): Specifies the network to be reshuffled. Expected to be an instance of a network class. Defaults to None.</li> </ul> </li> <li>Properties:<ul> <li><code>execution_time_mean</code>: Average time taken to execute the MTD strategy.</li> <li><code>execution_time_std</code>: Standard deviation of the time taken to execute the MTD strategy.</li> <li><code>priority</code>: Priority level of the MTD strategy.</li> </ul> </li> </ul>"},{"location":"mtdnetwork/mtd/mtdinit/#methods","title":"Methods","text":"<p>Comparison Operators (<code>__lt__</code>, <code>__gt__</code>, <code>__le__</code>, <code>__ge__</code>):</p> <ul> <li>Enable the comparison of MTD strategy objects based on their priority levels.</li> </ul> <p><code>__str__</code>:</p> <ul> <li>Returns a formatted string providing a concise representation of the MTD strategy.</li> </ul> <p><code>mtd_operation</code>:</p> <ul> <li>A placeholder method for implementing the specific operations of a MTD strategy. Raises a <code>NotImplementedError</code> in this base class.</li> </ul> <p>Getter Methods:</p> <ul> <li><code>get_mtd_type()</code>: Returns the type of MTD.</li> <li><code>get_resource_type()</code>: Returns the resource type.</li> <li><code>get_name()</code>: Returns the name of the MTD strategy.</li> <li><code>get_execution_time_mean()</code>: Returns the average execution time.</li> <li><code>get_execution_time_std()</code>: Returns the execution time's standard deviation.</li> <li><code>get_priority()</code>: Returns the priority of the MTD strategy.</li> </ul> <p>Setter Method:</p> <ul> <li><code>set_priority(priority)</code>: Sets the priority of the MTD strategy.</li> </ul>"},{"location":"mtdnetwork/mtd/mtdinit/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/data/constants</li> </ul>"},{"location":"mtdnetwork/mtd/osdiversity/","title":"OS Diversity","text":""},{"location":"mtdnetwork/mtd/osdiversity/#description","title":"Description","text":"<p>osdiversity. contains the <code>OSDiversity</code> class, a subclass of <code>MTD</code>.</p> <ul> <li>OS Diversity is an MTD strategy that seeks to diversify operating systems within a network in order to improve security</li> <li>Takes an optional <code>network</code> parameter, which the MTD strategy can be applied to</li> </ul> <p> <code>mtd_operation</code> method</p> <ul> <li>This method changes the OS of existing hosts, iteratively updating the service should a node within the host not be compatible with the new OS</li> <li>If the network is targeted (i.e., <code>get_network_type() == 0</code>), then the Attack Path Exposure Score is added to statistics for future use</li> <li>Takes an optional <code>adversary</code> parameter, however the code does not seem to use it</li> </ul>"},{"location":"mtdnetwork/mtd/osdiversity/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/mtd</li> <li>mtdnetwork/data/constants</li> </ul>"},{"location":"mtdnetwork/mtd/osdiversityassignment/","title":"OS Diversity Assignment","text":""},{"location":"mtdnetwork/mtd/osdiversityassignment/#description","title":"Description","text":"<p>osdiversityassignment.py contains 2 classes:</p> <ol> <li>The <code>OSDiversityAssignment</code> class which is a subclass of <code>MTD</code></li> <li>The <code>DiversityAssignment</code> supporting class, which is used in a <code>OSDiversityAssignment</code> method </li> </ol> <p><code>DiversityAssignment</code> class</p> <ul> <li>The class takes 6 parameters: <code>graph</code>, <code>sources</code>, <code>dests</code>, <code>os_types</code>, <code>pos</code>, <code>colour_map</code>; <code>pos</code> and <code>colour_map</code> are purely used for visualisations</li> <li><code>gen_single_connection_graph</code> method: <ul> <li>This method removes nodes in source and destination nodes found in <code>sources</code> and <code>dests</code> parameters and appears to connect them to the source and destination nodes</li> <li>It returns the modified graph</li> </ul> </li> <li><code>draw_dap_graph</code> method:<ul> <li>Purely for visualising the graph</li> </ul> </li> <li><code>calculate_variant_compromise_prob</code> method:<ul> <li>Takes a list of host IDs as <code>nodes</code> parameter</li> <li>Calculates the mean compromise probability for OS type in <code>nodes</code></li> </ul> </li> <li><code>objective</code> method:<ul> <li>This is the main method of the class; it effectively solves the OS diversity assignment by finding the optimal assignment of operating systems for a network graph</li> </ul> </li> </ul> <p><code>OSDiversityAssignment</code> class</p> <ul> <li>The class relies on the <code>DiversityAssignment</code> class</li> <li>It is initialised with 2 parameters: <code>network</code>, the network that the MTD strategy is applies to, and <code>os_types</code></li> <li><code>mtd_operation</code> method:<ul> <li>Takes optional <code>adversary</code> parameter, which does not appear to be used in code</li> <li>The method essentially assigns new operating system types and versions to each node of every host within the <code>network</code></li> </ul> </li> </ul>"},{"location":"mtdnetwork/mtd/osdiversityassignment/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/mtd</li> <li>mtdnetwork.data.constants</li> <li>mtdnetwork.statistic.utils</li> </ul>"},{"location":"mtdnetwork/mtd/portshuffle/","title":"Port Shuffle","text":""},{"location":"mtdnetwork/mtd/portshuffle/#description","title":"Description","text":"<p>portshuffle.py contains the <code>PortShuffle</code> class, a subclass of <code>MTD</code>.</p> <ul> <li>Port Shuffling is an MTD strategy that dynamically changes the ports associated with network services in order to decrease network predictability for attackers</li> <li>Takes an optional <code>network</code> parameter, which the MTD strategy can be applied to</li> </ul> <p><code>mtd_operation</code> method</p> <ul> <li>This method carries out the port shuffling on a particular network, updating the port of all nodes in a host should the host not be an endpoint</li> <li>Takes an optional <code>adversary</code> parameter, however the code does not seem to use it</li> </ul>"},{"location":"mtdnetwork/mtd/portshuffle/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/mtd</li> <li>mtdnetwork/component/host</li> </ul>"},{"location":"mtdnetwork/mtd/servicediversity/","title":"Service Diversity","text":""},{"location":"mtdnetwork/mtd/servicediversity/#description","title":"Description","text":"<p>servicediversity.py contains the <code>ServiceDiversity</code> class, a subclass of <code>MTD</code>.</p> <ul> <li>Service Diversity is an MTD strategy seeking to diversify network services, making it more difficult for attackers to predict vulnerabilities</li> <li>Parameters:<ul> <li>Takes optional <code>network</code> parameter, which the MTD strategy can be applied to</li> <li>Takes optional <code>shuffle</code> parameter defaulting to 50, which presumably determines the number of service shuffles, but does not appear to be used anywhere in the class</li> </ul> </li> </ul> <p><code>mtd_operation</code> method</p> <ul> <li>This method changes the services of each host, provided the host is not an endpoint</li> <li>If the network is targeted (i.e., <code>get_network_type() == 0</code>), then the Attack Path Exposure Score is added to statistics for future use</li> <li>Takes an optional <code>adversary</code> parameter, however the code does not seem to use it</li> <li>Note that the code systematically loops through host IDs and then randomly selects a host (<code>host_instance = random.choice(hosts)</code>); this is odd as no other similar MTD technique (e.g., OSdiversity, ipshuffle, etc.) does this</li> </ul>"},{"location":"mtdnetwork/mtd/servicediversity/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/mtd</li> </ul>"},{"location":"mtdnetwork/mtd/usershuffle/","title":"User Shuffle","text":""},{"location":"mtdnetwork/mtd/usershuffle/#description","title":"Description","text":"<p>usershuffle.py contains the <code>UserShuffle</code> class, a subclass of <code>MTD</code>.</p> <ul> <li>User Shuffle is an MTD strategy that randomly reassigns users to network hosts, which improves network security by making it more difficult for an attacker to predict what users are connected to specific hosts</li> <li>Parameters:<ul> <li>Takes optional <code>network</code> parameter, which the MTD strategy can be applied to</li> </ul> </li> </ul> <p> <code>mtd_operation</code> method</p> <ul> <li>This method loops through all the hosts of the network and reassigns a random user to each</li> </ul>"},{"location":"mtdnetwork/mtd/usershuffle/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/mtd</li> </ul>"},{"location":"mtdnetwork/operation/attack_operation/","title":"Attack Operation","text":""},{"location":"mtdnetwork/operation/attack_operation/#description","title":"Description","text":"<p><code>attack_operation.py</code> contains the <code>UserShuffle</code> class, a subclass of <code>MTD</code></p> <ul> <li>This class is used to initalize a new attack operation</li> </ul> <p></p> <p><code>proceed_attack</code> method:</p> <ul> <li>Proceeds with the attack simulation based on the current attack process of the adversary.</li> </ul> <p><code>_execute_attack_action</code> method:</p> <ul> <li>This method is used to execute a given time-consuming attack action. The method has two parameters:</li> <li><code>time</code> - The time duration before executing an attack action</li> <li><code>attack_action</code> - attack action</li> </ul> <p><code>_scan_host</code>method:</p> <ul> <li>This method is used to raise a SCAN_HOST action</li> </ul> <p><code>_enum_host</code> method:</p> <ul> <li>This method is used to raise a ENUM_HOST action</li> </ul> <p><code>_exploit_vuln</code> method:</p> <ul> <li>This method is used to raise an EXPLOIT_VULN action</li> </ul> <p><code>_brute_force</code> method:</p> <ul> <li>This method is used to raise an BRUTE_FORCE action</li> </ul> <p><code>_scan_neighbours</code> method:</p> <ul> <li>This method is used to raise a SCAN_NEIGHBOUR action</li> </ul> <p><code>_handle_interrupt</code> method:</p> <ul> <li>This method is used to handle the interrupt of the attack action caused by the MTD operations. The method has two parameters:</li> <li><code>start_time</code>: the start time of th action</li> <li><code>name</code>: the name of the attack action</li> </ul> <p><code>_execute scan_host</code> method:</p> <ul> <li>This method starts the network enumeration stage and sets up the order of hosts that the hacker will attempt to compromise</li> <li>The order is sorted by distance from the exposed endpoints which is done in the function <code>adversary.network.host_scan()</code>.</li> <li>If the scan returns nothing from the scan, then the attacker will stop</li> </ul> <p><code>_execute_enum_host</code> method:</p> <ul> <li>This method starts enumerating each host by poping off the host id from the top of the host stack. The time for host hopping is required.</li> <li>This method also checks if the hacker has already compromised and backdoored the target host.</li> </ul> <p><code>_execute_scan_port</code> method:   - Starts a port scan on the target host and checks if a compormised user has reused their credentials on the target host.</p> <p><code>_execute_exploit_vuln</code> method:</p> <ul> <li>This method finds the top 5 vulnerabilities based on RoA score and tries exploiting the vulnerabilities to compromise the host.</li> </ul> <p><code>_execute_brute_force</code> method:</p> <ul> <li>This method tries bruteforcing a login for a short periods of time using previous passwords from compromised user accounts to guess a new login.</li> <li>This method also checks if id credentails for a user account has been successfully compromised</li> </ul> <p><code>_execute_scan_neighbour</code> method:</p> <ul> <li>This method starts scanning for neighbours for a host that the hack can pivot to and puts the new neighbours discovered to the start of the host stack.</li> </ul> <p><code>_sect_next_pivot_host</code> method:</p> <ul> <li>This method sets the next host that the hacker will pivor from to compormise other hosts. The pivot host needs to be a comprmoised host the hack can access</li> </ul> <p><code>update_compromise_method</code> method:</p> <ul> <li>This method updates the hacker's progress state when it compromises a host</li> </ul> <p><code>get_proceed_time</code> method:</p> <ul> <li>This method returns the proceed time</li> </ul> <p><code>set_proceed_time</code> method:</p> <ul> <li>This method sets the proceed time</li> </ul> <p><code>get_attack_process</code> method:</p> <ul> <li>This method returns the attack process</li> </ul> <p><code>set_attack_</code> process method:</p> <ul> <li>This method sets the attack process</li> </ul> <p><code>set_interrupted_mtd</code> method:</p> <ul> <li>This method sets the interrupted MTD operation</li> </ul> <p><code>get_adversary</code> method:</p> <ul> <li>This method returns the adversary </li> </ul> <p></p>"},{"location":"mtdnetwork/operation/attack_operation/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/component/time_generator/exponential_variates</li> <li>mtdnetwork/data.constants/ATTACK_DURATION</li> </ul>"},{"location":"mtdnetwork/operation/mtd_operation/","title":"MTD Operation Class","text":"<p><code>mtd_operation</code> is the main class for the execution and management of Moving Target Defense (MTD) strategies during network simulations.</p>"},{"location":"mtdnetwork/operation/mtd_operation/#description","title":"Description","text":"<p>The <code>mtd_operation</code> class encapsulates the functionality required to execute, suspend, trigger, and manage MTD strategies within a network. It interacts with the network environment and use the simpy library for manage these events. The class determines when to deploy a strategy, how to handle resource conflicts, and manages MTD registration and suspension.</p>"},{"location":"mtdnetwork/operation/mtd_operation/#initialization","title":"Initialization","text":"<ul> <li> <p>Parameters:</p> <ul> <li><code>env</code>: Facilitates the simpy environment framework.</li> <li><code>end_event</code>: Marks the end of a simulation event.</li> <li><code>network</code>: Refers to the simulation network.</li> <li><code>attack_operation</code>: Represents the attack operation in the network.</li> <li><code>scheme</code>: Specifies how MTDs are executed and can be done in  <code>alternatively</code>, <code>simultaneously</code>, or <code>randomly</code>.</li> <li><code>proceed_time</code> (optional): Time to progress MTD simulation. Defaults to 0.</li> <li><code>mtd_trigger_interval</code> (optional): The time interval to trigger MTD strategies. Defaults to None.</li> <li><code>custom_strategies</code> (optional): Custom MTD priority strategies for alternative or single schemes. Defaults to None.</li> </ul> </li> <li> <p>Several <code>simpy.Resource</code> instances represent resources like application layer, network layer, and a reserve for potential MTD execution.</p> </li> </ul>"},{"location":"mtdnetwork/operation/mtd_operation/#methods","title":"Methods","text":"<p><code>proceed_mtd</code>:</p> <ul> <li>Initiates the MTD process, checking for unfinished MTDs and suspending them. Decides the MTD scheme (batch or individual) to trigger.</li> </ul> <p><code>_mtd_trigger_action</code>:</p> <ul> <li>The core function for triggering individual MTD strategies at exponential time intervals. It checks for network compromise and then decides to either register, trigger, or suspend an MTD strategy based on resource occupation conditions.</li> </ul> <p><code>_mtd_batch_trigger_action</code>:</p> <ul> <li>This function triggers the suspended MTDs based on priority if available, otherwise registers and triggers all MTDs simultaneously. It continuously checks if the network is compromised and decides to either register, trigger, or suspend MTDs in batches based on resource occupation. Then, It waits for an exponentially distributed time interval before initiating the next round of MTD operations.</li> </ul> <p><code>_mtd_execute_action</code>:</p> <ul> <li>This function is an action for executing an MTD strategy. Once an MTD is deployed, it waits for a certain period, checks for network compromise, and then executes the MTD. After execution, it logs necessary details, releases the occupied resource, and interrupts the adversary's operation if required.</li> </ul> <p><code>_get_mtd_resource</code>:</p> <ul> <li>Given an MTD, this function determines which resource (network, application, or reserve) the MTD will occupy or use.</li> </ul> <p><code>_interrupt_adversary</code>:</p> <ul> <li>This function interrupts the adversary's attack process based on the type of MTD triggered and the current attack process. If there's an ongoing attack process and the MTD affects the <code>network</code> resource, the function interrupts the attack process irrespective of its type. If the MTD affects the <code>application</code> resource, the function will only interrupt the adversary's attack if the attack isn't in the processes of <code>SCAN_HOST</code>, <code>ENUM_HOST</code>, or <code>SCAN_NEIGHBOR</code>.</li> </ul> <p>Getter Methods:</p> <ul> <li><code>get_proceed_time()</code>: Returns the time taken to progress the MTD simulation.</li> <li><code>get_application_resource()</code>: Retrieves the application layer resource.</li> <li><code>get_network_resource()</code>: Retrieves the network layer resource.</li> <li><code>get_reserve_resource()</code>: Retrieves the reserve resource.</li> <li><code>get_mtd_scheme()</code>: Returns the current MTD scheme in use.</li> </ul>"},{"location":"mtdnetwork/operation/mtd_operation/#dependencies","title":"Dependencies","text":"<ul> <li>mtdnetwork/component/time_generator</li> <li>mtdnetwork/data/constants</li> </ul>"},{"location":"mtdnetwork/statistic/evaluation/","title":"Evaluation","text":"<p>The <code>Evaluation</code> class in <code>evaluation.py</code> serves to derive useful statistics from the <code>Network</code> and <code>Adversary</code> objects of the simulation.</p>"},{"location":"mtdnetwork/statistic/evaluation/#description","title":"Description","text":"<p>The <code>Evaluation</code> class mainly compiles the statistics data stored in the <code>Network</code> and <code>Adversary</code> objects into graphs and summarized metrics for human viewing using matplotlib.</p>"},{"location":"mtdnetwork/statistic/evaluation/#initialization","title":"Initialization","text":"<ul> <li>Parameters<ul> <li><code>network</code>: a network object (usually <code>time_network</code>), typically of the final state of the simulation.</li> <li><code>adversary</code>: an adversary object, typically of the final state of the simulation.</li> </ul> </li> </ul>"},{"location":"mtdnetwork/statistic/evaluation/#properties","title":"Properties","text":"<ul> <li><code>network</code>: Network object.</li> <li><code>adversary</code>: Adversary object.</li> <li><code>mtd_record</code>: MTD statistics from the network object.</li> <li><code>attack_record</code>: Attack statistics from the adversary object.</li> </ul>"},{"location":"mtdnetwork/statistic/evaluation/#methods","title":"Methods","text":"<ul> <li> <p><code>compromised_num()</code>:</p> <ul> <li> <p>Parameters</p> <ul> <li><code>record</code>: an attack record.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li>Number of compromised hosts.</li> </ul> </li> </ul> </li> <li> <p><code>mtd_execution_frequency()</code>:     The frequency of executing MTDs.</p> <ul> <li>Returns: Total number of executed MTD / Elapsed time.</li> </ul> </li> <li> <p><code>evaluation_result_by_compromise_checkpoint()</code>:     Metrics at compromise checkpoints (% compromise)</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>checkpoint</code>: an array of decimal compromise ratios (i.e. 0.1).</li> </ul> </li> <li> <p>Returns:</p> <ul> <li>an array of dictionaries of compromise ratios and metrics</li> <li>{  <code>\"time_to_compromise\"</code>,  <code>\"attack_succes_rate\"</code>,  <code>\"host_compromise_ratio\"</code>,  <code>\"mtd_execution_frequency\"</code>  }</li> </ul> </li> <li><code>compromise_record_by_attack_action()</code>:</li> <li>Parameters:<ul> <li><code>action</code>: a specified attack action.</li> </ul> </li> <li>Returns:<ul> <li>a list containing hosts compromised by the given action.</li> </ul> </li> </ul> </li> <li> <p><code>draw_network()</code>:     Draws the topology of the network while also highlighting compromised and exposed endpoint nodes.</p> </li> <li> <p><code>draw_hacker_visible()</code>:     Draws the network that is visible for the hacker.</p> </li> <li> <p><code>draw_compromised()</code>:     Draws the network of compromised hosts.</p> </li> <li> <p><code>visualise_attack_operation_group_by_host()</code>:     Visualises the action flow of attack operations by host ids.</p> </li> <li> <p><code>visualise_attack_operation()</code>:     Visualises the action flow of attack operations by attack type.</p> </li> <li> <p><code>visualise_mtd_operation()</code>:     Visualises the action flow of mtd operations.</p> </li> </ul>"},{"location":"mtdnetwork/statistic/evaluation/#getter-methods","title":"Getter Methods","text":"<ul> <li><code>get_network()</code>: Returns network object.</li> </ul>"},{"location":"mtdnetwork/statistic/evaluation/#dependencies","title":"Dependencies","text":"<ul> <li><code>numpy</code></li> <li><code>matplotlib/pyplot</code></li> <li><code>matplotlib/lines</code></li> <li><code>networkx</code></li> <li><code>pandas</code></li> <li><code>os</code></li> </ul>"},{"location":"user/download_instructions/","title":"Download MTD Simulator Application","text":"<p>Currently we have not purchased the devlepment license for MacOS and Windows, so the application is not signed. You will need to bypass the security check to run the application. The steps on how to do so will be in the respective sections below.</p> <p>The docs will update in due course when the license's is purchased.</p> <p>NOTE: it is currently recommended that MacOS users use the website version over the application.</p>"},{"location":"user/download_instructions/#windows","title":"Windows","text":"<ol> <li>Navigate to the Github Releases</li> <li>Click <code>MTDSimTime.exe</code> file</li> <li>Click <code>Run Anyway</code> to bypass Windows security</li> </ol>"},{"location":"user/download_instructions/#macos","title":"MacOS","text":"<ol> <li>Navigate to Download page.</li> <li>Click the <code>MTDSimTime.zip</code> file.</li> <li>Unzip the file, this will place the application in the folder where you unzipped it.</li> <li>Right click the application and click <code>Open</code>, this will cause the application to hang for a little bit.</li> <li>If there is a error from electron saying that there was no code signature found, click ok and then the icon in the tray. The app will then run like normal.</li> </ol>"},{"location":"user/download_instructions/#linux","title":"Linux","text":"<ol> <li>Navigate to the Github Releases</li> <li>Click the <code>test_0.0.6_amd64.deb</code> file.</li> <li>Right click <code>test_0.0.6_amd64.deb</code> file and choose <code>Open with Another Application</code></li> <li>Select <code>Software Install</code> from the program list.</li> <li>Click the <code>install</code> button and enter the user's password to authenticate</li> </ol>"},{"location":"user/simulation_instructions/","title":"MTD Simulator","text":""},{"location":"user/simulation_instructions/#moving-target-defence","title":"Moving Target Defence","text":"<p>Moving Target Defence (MTD) is a proposed mechanism to reduce the efforts of cyberattacks by continuously reconfiguring system components to increase uncertainty and complexity.</p>"},{"location":"user/simulation_instructions/#run-simulation","title":"Run Simulation","text":"<ol> <li>Launch MTD Simulator app or open web application.</li> <li>Navigate to simulation tab.</li> <li>Input simulation parameters or choose a pre-set simulation scenario. </li> <li>Click <code>Submit</code> to generate network graph and summary graphs.</li> </ol>"},{"location":"user/simulation_instructions/#simulation-parameters","title":"Simulation Parameters","text":"Parameter Description Scheme The manner in which the simulation will employ MTD strategies MTD Interval The frequency that MTD strategies are applied Total Nodes The number of nodes in the simulated network Finish Time The maximum simulation duration Total Endpoints The number of endpoints in the simulated network Total Subnets The number of sub-networks in the simulated network, randomly spread between layers Total Databases The number of databases for the simulated network Total Layers The number of layers in the simulated network Target Layer The layer where the target node will be located on, if a targetted attack"}]}